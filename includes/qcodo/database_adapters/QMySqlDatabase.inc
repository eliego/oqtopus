<?php
	/* Qcodo Development Framework for PHP
	 * http://www.qcodo.com/
	 * 
	 * The Qcodo Development Framework is distributed by QuasIdea Development, LLC
	 * under the terms of The MIT License.  More information can be found at
	 * http://www.opensource.org/licenses/mit-license.php
	 * 
	 * Copyright (c) 2001 - 2006, QuasIdea Development, LLC
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy of
	 * this software and associated documentation files (the "Software"), to deal in
	 * the Software without restriction, including without limitation the rights to
	 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 * of the Software, and to permit persons to whom the Software is furnished to do
	 * so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */

	// This Database Adapter depends on MySqliDatabase	
	require(__INCLUDES__ . 'qcodo/database_adapters/QMySqliDatabase.inc');

	class QMySqlDatabase extends QMySqliDatabase {
		protected $objDb;

		public function __construct($intDatabaseIndex) {
			// Configure Base Properties
			$this->ConfigureBaseProperties($intDatabaseIndex);

			// Lookup Adapter-Specific Connection Properties
			$strServer = QApplication::$ConnectionStringArray[$intDatabaseIndex]['server'];
			$strName = QApplication::$ConnectionStringArray[$intDatabaseIndex]['database'];
			$strUsername = QApplication::$ConnectionStringArray[$intDatabaseIndex]['username'];
			$strPassword = QApplication::$ConnectionStringArray[$intDatabaseIndex]['password'];
			$strPort = QApplication::$ConnectionStringArray[$intDatabaseIndex]['port'];

			if ($strPort)
				$strServer .= ':' . $strPort;

			// Connect to the Database Server
			$this->objDb = mysql_connect($strServer, $strUsername, $strPassword);
			if (!$this->objDb)
				throw new QMySqliDatabaseException("Unable to connect to Database Server: $strServer", -1, null);
			if (mysql_errno($this->objDb))
				throw new QMySqliDatabaseException(mysql_error($this->objDb), mysql_errno($this->objDb), null);

			// Select the DB
			if (!mysql_select_db($strName, $this->objDb))
				throw new QMySqliDatabaseException("Unable to select the Database: $strName", -1, null);
			if (mysql_errno($this->objDb))
				throw new QMySqliDatabaseException(mysql_error($this->objDb), mysql_errno($this->objDb), null);

			// Set to AutoCommit
			$this->NonQuery('SET AUTOCOMMIT=1;');
		}

		public function __get($strName) {
			switch ($strName) {
				case 'AffectedRows':
					return mysql_affected_rows($this->objDb);
				default:
					try {
						return parent::__get($strName);
					} catch (QCallerException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}
			}
		}

		public function Query($strQuery) {
			// Log Query (for Profiling, if applicable)
			$this->LogQuery($strQuery);

			// Perform the Query
			$objResult = mysql_query($strQuery, $this->objDb);			
			if (mysql_errno($this->objDb))
				throw new QMySqliDatabaseException(mysql_error($this->objDb), mysql_errno($this->objDb), $strQuery);

			// Return the Result
			$objMySqlDatabaseResult = new QMySqlDatabaseResult($objResult, $this);
			return $objMySqlDatabaseResult;
		}

		public function NonQuery($strNonQuery) {
			// Log Query (for Profiling, if applicable)
			$this->LogQuery($strNonQuery);

			// Perform the Query
			mysql_query($strNonQuery, $this->objDb);
			if (mysql_errno($this->objDb))
				throw new QMySqliDatabaseException(mysql_error($this->objDb), mysql_errno($this->objDb), $strNonQuery);
		}

		public function InsertId($strTableName = null, $strColumnName = null) {
			return mysql_insert_id($this->objDb);
		}

		public function Close() {
			mysql_close($this->objDb);
		}
	}

	class QMySqlDatabaseResult extends QMySqliDatabaseResult {
		protected $objMySqlResult;
		protected $objDb;

		public function __construct($objResult, QMySqlDatabase $objDb) {
			$this->objMySqlResult = $objResult;
			$this->objDb = $objDb;
		}

		public function FetchArray() {
			return mysql_fetch_array($this->objMySqlResult);
		}

		public function FetchFields() {
			$objArrayToReturn = array();
			while ($objField = mysql_fetch_field($this->objMySqlResult)) {
				array_push($objArrayToReturn, new QMySqlDatabaseField($objField, $this->objDb));
			}
			return $objArrayToReturn;
		}

		public function FetchField() {
			if ($objField = mysql_fetch_field($this->objMySqlResult))
				return new QMySqlDatabaseField($objField, $this->objDb);
		}

		public function FetchRow() {
			return mysql_fetch_row($this->objMySqlResult);
		}

		public function CountRows() {
			return mysql_num_rows($this->objMySqlResult);
		}

		public function CountFields() {
			return mysql_num_fields($this->objMySqlResult);
		}

		public function Close() {
			mysql_free_result($this->objMySqlResult);
		}
		
		public function GetNextRow() {
			$strColumnArray = $this->FetchArray();
			
			if ($strColumnArray)
				return new QMySqliDatabaseRow($strColumnArray);
			else
				return null;
		}

		public function GetRows() {
			$this->objDbRowArray = array();
			while ($this->objDbRow = $this->GetNextRow())
				array_push($this->objDbRowArray, $this->objDbRow);
			return $this->objDbRowArray;
		}
	}
	
	class QMySqlDatabaseField extends QMySqliDatabaseField {
		public function __construct($mixFieldData, $objDb = null) {
			$this->strName = $mixFieldData->name;
			$this->strOriginalName = $this->strName;
			$this->strTable = $mixFieldData->table;
			$this->strOriginalTable = $mixFieldData->table;
			$this->strDefault = $mixFieldData->def;
			$this->intMaxLength = null;

			// Calculate MaxLength of this column (e.g. if it's a varchar, calculate length of varchar
			// Also, see if it's auto increment
			$objDescriptionResult = $objDb->Query(sprintf("DESCRIBE `%s`", $this->strOriginalTable));
			while (($objRow = $objDescriptionResult->FetchArray())) {
				if ($objRow["Field"] == $this->strOriginalName) {
					if ($objRow["Extra"] == 'auto_increment')
						$this->blnIdentity = true;
					else
						$this->blnIdentity = false;

					$strLengthArray = explode("(", $objRow["Type"]);
					if ((count($strLengthArray) > 1) &&
						(strtolower($strLengthArray[0]) != 'enum') &&
						(strtolower($strLengthArray[0]) != 'set')) {
						$strLengthArray = explode(")", $strLengthArray[1]);
						$this->intMaxLength = $strLengthArray[0];
						if (!is_numeric($this->intMaxLength))
							throw new Exception("Not a valid Column Length: " . $objRow["Type"]);			
					}
				}
			}

			$this->blnNotNull = QType::Cast($mixFieldData->not_null, QType::Boolean);
			$this->blnPrimaryKey = QType::Cast($mixFieldData->primary_key, QType::Boolean);
			$this->blnUnique = QType::Cast($mixFieldData->unique_key, QType::Boolean);

			switch ($mixFieldData->type) {
				case 'int':
					if ($this->intMaxLength == 1)
						$this->strType = QDatabaseFieldType::Bit;
					else
						$this->strType = QDatabaseFieldType::Integer;
					break;
				case 'real':
				case 'float':
					$this->strType = QDatabaseFieldType::Float;
					break;
				case 'double':
					// NOTE: PHP does not offer full support of double-precision floats.
					// Value will be set as a VarChar which will guarantee that the precision will be maintained.
					//    However, you will not be able to support full typing control (e.g. you would
					//    not be able to use a QFloatTextBox -- only a regular QTextBox)
					$this->strType = QDatabaseFieldType::VarChar;
					break;
				case 'timestamp':
					// System-generated Timestamp values need to be treated as plain text
					$this->strType = QDatabaseFieldType::VarChar;
					$this->blnTimestamp = true;
					break;
				case 'date':
					$this->strType = QDatabaseFieldType::Date;
					break;
				case 'time':
					$this->strType = QDatabaseFieldType::Time;
					break;
				case 'datetime':
					$this->strType = QDatabaseFieldType::DateTime;
					break;
				case 'blob':
					$this->strType = QDatabaseFieldType::Blob;
					break;
				case 'string':
					$this->strType = QDatabaseFieldType::VarChar;
					break;
				case 'char':
					$this->strType = QDatabaseFieldType::Char;
					break;
				default:
					throw new Exception("Unable to determine MySqli Database Field Type: " . $mixFieldData->type);
					break;
			}
		}
	}
?>